<?php
/**
 * @file
 * Main module file for Persona.
 */

/**
 * Gets the session's XSRF token, generating it if necessary.
 *
 * @return string
 *   XSRF token.
 */
function persona_xsrf_token() {
  // Make sure we have a session.
  drupal_session_start();
  if (!isset($_SESSION['persona_xsrf_token'])) {
    $_SESSION['persona_xsrf_token'] = drupal_get_token('persona-xsrf');
  }
  return $_SESSION['persona_xsrf_token'];
}

/**
 * Implements hook_init().
 */
function persona_init() {
  global $user, $is_https;
  // Send X-UA-Compatible HTTP header to force IE to use the most recent
  // rendering engine or use Chrome's frame rendering engine if available. It is
  // not possible to use drupal_add_http_header() as Drupal 7 does not store
  // HTTP headers in the page cache.
  // @see https://developer.mozilla.org/en-US/docs/Persona/Browser_compatibility
  $element = array(
    '#tag' => 'meta',
    '#attributes' => array(
      'http-equiv' => 'X-UA-Compatible',
      'content' => 'IE=edge,chrome=1',
    ),
  );
  drupal_add_html_head($element, 'x_ua_compatible');
  // Add JavaScript settings.
  $settings = array(
    // Tell Persona who is signed in.
    'email' => (user_is_logged_in() && isset($_SESSION['persona_sign_in'])) ? $user->mail : NULL,
    // Add site name to display on Mozilla Persona dialog.
    'siteName' => variable_get('site_name'),
    // Add some settings that core doesn't provide.
    // @see http://drupal.org/node/1691394
    'cleanUrls' => variable_get('clean_url'),
    'currentPath' => (current_path() == variable_get('site_frontpage', 'node')) ? '' : current_path(),
  );
  // Don't add the XSRF token if the user is not signed in as the page may be
  // cached. This also avoids creating a session.
  if (user_is_logged_in()) {
    $settings['token'] = persona_xsrf_token();
  }
  // Add the legal documents if they are both provided.
  if ((variable_get('persona_terms_link') != '') && (variable_get('persona_privacy_link') != '')) {
    $settings += array(
      'termsOfService' => url(variable_get('persona_terms_link'), array('absolute' => TRUE)),
      'privacyPolicy' => url(variable_get('persona_privacy_link'), array('absolute' => TRUE)),
    );
  }
  // Site logo can only be displayed on Mozilla Persona dialog if it can be
  // served over HTTPS.
  if ($is_https && (theme_get_setting('logo') != '')) {
    $settings['siteLogo'] = theme_get_setting('logo');
  }
  drupal_add_js(array('persona' => $settings), 'setting');
  // Add the Persona JavaScript library. The documentation recommends putting
  // this at the bottom of the page body, but this causes a significant delay
  // before Drupal behaviours are activated causing visible page rearrangement.
  // @see https://developer.mozilla.org/en-US/docs/Persona/Quick_Setup
  // TODO: Conditionally include this file only for browsers that don't
  // implement navigator.id natively (currently all of them).
  // @see https://developer.mozilla.org/en-US/docs/DOM/navigator.id
  // @see http://drupal.org/node/865536
  drupal_add_js('https://login.persona.org/include.js', array(
    'group' => JS_LIBRARY,
    'every_page' => TRUE,
  ));
}

/**
 * Implements hook_menu().
 */
function persona_menu() {
  $items['user/persona/get-token'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'persona_xsrf_token',
    'delivery callback' => 'drupal_json_output',
    'access callback' => TRUE,
  );
  $items['user/persona/sign-in'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'persona_sign_in',
    'delivery callback' => 'drupal_json_output',
    'access callback' => TRUE,
  );
  $items['user/persona/change-email'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'persona_change_email',
    'delivery callback' => 'drupal_json_output',
    'access callback' => TRUE,
  );
  $items['user/persona/sign-out'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'persona_sign_out',
    'delivery callback' => 'drupal_json_output',
    'access callback' => TRUE,
  );
  $items['admin/config/people/persona'] = array(
    'title' => "Persona settings",
    'type' => MENU_NORMAL_ITEM,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('persona_admin_form'),
    'description' => "Configure settings for signing in with Mozilla Persona.",
    'file' => 'persona.admin.inc',
    'access arguments' => array('administer site configuration'),
  );
  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function persona_menu_alter(array &$items) {
  if (variable_get('persona_takeover')) {
    unset($items['user/register']);
    unset($items['user/login']);
    unset($items['user/password']);
    unset($items['user/logout']);
  }
}

/**
 * Determines if a user with a specific name already exists.
 *
 * @param string $name
 *   User name to check for.
 *
 * @return bool
 *   TRUE if the name is taken.
 */
function _persona_username_exists($name) {
  // Search for a user entity with the supplied name.
  $query = new EntityFieldQuery;
  return (bool) $query->entityCondition('entity_type', 'user')
    ->propertyCondition('name', $name)
    ->count()
    ->execute();
}

/**
 * Extracts a unique name from an email address.
 *
 * @param string $email
 *   Email address to extract name from.
 *
 * @return string
 *   Unique extracted name. No existing users will have this name.
 */
function _persona_extract_username($email) {
  // Extract the local-part from the email address if not using email usernames.
  $name = variable_get('persona_email_usernames') ? $email : strtok($email, '@');
  // Ensure it is unique.
  if (_persona_username_exists($name)) {
    $i = 2;
    do {
      $attempt = $name . '-' . $i++;
    } while (_persona_username_exists($attempt));
    $name = $attempt;
  }
  return $name;
}

/**
 * Determines request variables from JSON POST data.
 *
 * @return array
 *   Keyed array of request variables.
 */
function _persona_request_variables() {
  return drupal_json_decode(file_get_contents('php://input'));
}

/**
 * Ensures XSRF token is correct.
 */
function _persona_check_xsrf_token($token) {
  if (!isset($_SESSION['persona_xsrf_token']) || ($_SESSION['persona_xsrf_token'] != $token)) {
    watchdog('persona', "Bad XSRF token.", array(), WATCHDOG_WARNING);
    throw new Exception();
  }
}

/**
 * Returns the audience URL that assertions should be verified with.
 *
 * @return string
 *   Audience URL.
 */
function _persona_audience() {
  global $is_https;
  $audience = variable_get('persona_audience');
  // Determine audience insecurely if not defined.
  if (!$audience) {
    $audience = 'http' . ($is_https ? 's'  : '') . '://';
    $audience .= $_SERVER['HTTP_HOST'];
    $audience .= ':' . $_SERVER['SERVER_PORT'];
  }
  return $audience;
}

/**
 * Verifies a Persona assertion and determines the email address.
 *
 * @return string
 *   Email address that the user has signed in with.
 */
function persona_verify($assertion) {
  global $base_url;
  // Verify assertion with Mozilla's Remote Verification API.
  // TODO: Support local verification once API has stabilized, for example with
  // https://github.com/Falco20019/php-browseridlib
  $context_options = array(
    'ssl' => array(
      'verify_peer' => TRUE,
      'cafile' => drupal_get_path('module', 'persona') . '/cacert.pem',
      'CN_match' => 'www.persona.org',
    ),
  );
  $result = (array) drupal_http_request('https://verifier.login.persona.org/verify', array(
    'method' => 'POST',
    'headers' => array('Content-Type' => 'application/json'),
    'data' => drupal_json_encode(array(
      'assertion' => $assertion,
      'audience' => _persona_audience(),
    )),
    'context' => stream_context_create($context_options),
  ));
  // Get response variables.
  $response = drupal_json_decode($result['data']);
  // HTTP status should be 200, and verification status should be 'okay'.
  if (($result['code'] != 200) || ($response['status'] != 'okay')) {
    watchdog('persona', "Bad response: @response; HTTP status: @code", array(
      '@response' => var_export($response, TRUE),
      '@code' => $result['code'],
    ), WATCHDOG_ERROR);
    throw new Exception();
  }
  // Return email address obtained from assertion.
  return $response['email'];
}

/**
 * Signs into an account.
 *
 * @param $account
 *   Account to sign into.
 */
function _persona_sign_in($account) {
  global $user;
  // Are we already signed in?
  if (user_is_logged_in()) {
    // @see user_logout()
    watchdog('user', 'Session closed for %name.', array('%name' => $user->name));
    module_invoke_all('user_logout', $user);
  }
  $user = $account;
  user_login_finalize();
  // Store in the session the fact that the user signed in with Persona.
  $_SESSION['persona_sign_in'] = TRUE;
}

/**
 * Attempts to sign into an existing account.
 *
 * @param $account
 *   Account to sign into.
 */
function _persona_existing_account_sign_in($account) {
  if ($account->status) {
    watchdog('persona', "Sign into existing account by %email successful.", array('%email' => $account->mail));
    _persona_sign_in($account);
    drupal_add_http_header('Status', '204 No Content');
  }
  else {
    watchdog('persona', "Sign in by %email to blocked account denied.", array('%email' => $account->mail), WATCHDOG_WARNING);
    drupal_set_message(t("You are not allowed to sign in at this time."), 'error');
    drupal_add_http_header('Status', '403 Forbidden');
  }
  return $account->status;
}

/**
 * Callback function to sign in with Persona.
 */
function persona_sign_in() {
  global $user;
  $request = _persona_request_variables();
  try {
    _persona_check_xsrf_token($request['token']);
    $email = persona_verify($request['assertion']);
  }
  catch (Exception $e) {
    drupal_add_http_header('Status', '401 Unauthorized');
    drupal_set_message(t("Sorry, there was a problem signing you in with Persona."), 'error');
    return;
  }
  // Is the browser already signed in as this user.
  if (user_is_logged_in() && ($user->mail == $email)) {
    drupal_add_http_header('Status', '204 No Content');
  }
  // Does an account with this email already exist.
  elseif ($account = user_load_by_mail($email)) {
    _persona_existing_account_sign_in($account);
  }
  // Are users allows to create new accounts?
  elseif (variable_get('user_register')) {
    // Create an account for this user.
    $fields = array(
      'name' => _persona_extract_username($email),
      'pass' => user_password(16),
      'mail' => $email,
      'access' => REQUEST_TIME,
      'status' => (variable_get('user_register') == USER_REGISTER_VISITORS),
      'init' => $email,
    );
    $account = user_save(drupal_anonymous_user(), $fields);
    // Reload the account to get full object and prevent warnings.
    $account = user_load($account->uid);
    // Sign into account if it doesn't need approval.
    if ($account->status) {
      watchdog('persona', "Sign in to new account by %email successful.", array('%email' => $email));
      // Sign the browser into the account.
      _persona_sign_in($account);
      drupal_add_http_header('Status', '201 Created');
      // Redirect to account edit page if new accounts are set to do so.
      if (variable_get('persona_new_account_edit')) {
        return 'user/' . $account->uid . '/edit';
      }
    }
    else {
      watchdog('persona', "Account created during sign in by %email pending approval.", array('%email' => $email));
      _user_mail_notify('register_pending_approval', $account);
      drupal_set_message(t("Thank you for applying for an account. Your account is currently pending approval by the site administrator.<br />In the meantime, a welcome message with further instructions has been sent to your email address."));
      drupal_add_http_header('Status', '403 Forbidden');
    }
  }
  else {
    // Visitors cannot create accounts.
    watchdog('persona', "Attempted sign in without an account by %email.", array('%email' => $email), WATCHDOG_WARNING);
    drupal_set_message(t("Only administrators are permitted to register new accounts on this website."), 'error');
    drupal_add_http_header('Status', '403 Forbidden');
  }
}

/**
 * Callback function to change email address with Persona.
 */
function persona_change_email() {
  global $user;
  $request = _persona_request_variables();
  try {
    _persona_check_xsrf_token($request['token']);
    $email = persona_verify($request['assertion']);
  }
  catch (Exception $e) {
    drupal_add_http_header('Status', '401 Unauthorized');
    drupal_set_message(t("Sorry, there was a problem changing your email address with Persona."), 'error');
    return;
  }
  // Check if the user is using this email address in another account.
  $account = user_load_by_mail($email);
  if ($account) {
    // Sign into existing account as it is all we can do...
    if (_persona_existing_account_sign_in($account)) {
      drupal_set_message(t("You are already using %email for another account, which you have now been signed into.", 
        array('%email' => $user->mail)), 'error');
    }
  }
  else {
    // Update account email address.
    $old_email = $user->mail;
    $user->mail = $email;
    if (variable_get('persona_email_usernames')) {
      // Update account username.
      $user->name = _persona_extract_username($email);
    }
    user_save($user);
    watchdog('persona', "%old_email changed to %email.", array(
      '%name' => $old_email,
      '%email' => $email,
    ));
    drupal_set_message(t("Your email address has been changed to %email.", array('%email' => $user->mail)));
    drupal_add_http_header('Status', '204 No Content');
  }
}

/**
 * Callback function to sign out with Persona.
 *
 * Unlike core's sign out handler, this function does not issue an HTTP
 * redirect.
 *
 * @see user_logout()
 */
function persona_sign_out() {
  global $user;
  $request = _persona_request_variables();
  try {
    _persona_check_xsrf_token($request['token']);
  }
  catch (Exception $e) {
    return;
  }
  if (user_is_logged_in()) {
    watchdog('user', 'Session closed for %name.', array('%name' => $user->name));
    module_invoke_all('user_logout', $user);
    // Destroy the current session, and reset $user to the anonymous user.
    session_destroy();
  }
  drupal_add_http_header('Status', '204 No Content');
}

/**
 * Implements hook_theme().
 */
function persona_theme() {
  return array(
    'persona_button' => array(
      'variables' => array('type' => NULL),
    ),
  );
}

/**
 * Renders a Persona button.
 *
 * @param $variables
 *   An associative array containing:
 *   - type: Button to render.
 *
 * @return string
 *   HTML of generated button.
 */
function theme_persona_button(array $variables) {
  drupal_add_css(drupal_get_path('module', 'persona') . '/persona-buttons.css');
  $type = $variables['type'];
  // Create "switch account" button instead of "sign in" if already signed in.
  if (!$type) {
    $type = user_is_logged_in() ? 'switch_account' : 'sign_in';
  }
  // Determine CSS classes and text.
  $classes = array('persona-' . $type);
  switch ($type) {
    case 'sign_in':
      $text = t("sign in");
      $classes[] = 'persona-sign-in';
      break;
    case 'switch_account':
      $text = t("switch account");
      $classes[] = 'persona-sign-in';
      break;
    case 'change_email':
      $text = t("change account email");
      $classes[] = 'persona-change-email';
      break;
    case 'sign_out':
      $text = t("sign out");
      $classes[] = 'persona-sign-out';
      break;
  }
  $style = variable_get('persona_button_style');
  if ($style != '') {
    $classes[] = 'persona-button';
    $classes[] = $style;
  }
  // Generate HTML.
  $text = '<span>' . $text . '</span>';
  $attributes = array('class' => $classes);
  if ($type == 'sign_out' && !isset($_SESSION['persona_sign_in'])) {
    $html = l($text, 'user/logout', array('attributes' => $attributes, 'html' => TRUE));
  }
  else {
    $html = '<div ' .  drupal_attributes($attributes) . '>' . $text . '</div>';
  }
  return $html;
}

/**
 * Implements hook_block_info().
 */
function persona_block_info() {
  $blocks = array(
    'buttons' => array(
      'info' => t("Persona buttons"),
    ),
  );
  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function persona_block_configure($delta = '') {
  $form['switch_account'] = array(
    '#type' => 'checkbox',
    '#title' => t("Display \"switch account\" button when signed in."),
    '#default_value' => variable_get('persona_block_switch_account'),
  );
  return $form;
}

/**
 * Implements hook_block_save().
 */
function persona_block_save($delta = '', array $edit = array()) {
  variable_set('persona_block_switch_account', $edit['switch_account']);
}

/**
 * Implements hook_block_view().
 */
function persona_block_view($delta) {
  // If we are on the standard sign in page, don't display this block.
  if (!user_is_logged_in() && arg(0) == 'user' && !is_numeric(arg(1))) {
    return array();
  }
  // Create the buttons.
  $buttons = array();
  if (!user_is_logged_in() || variable_get('persona_block_switch_account')) {
    $buttons[] = array('#theme' => 'persona_button');
  }
  if (user_is_logged_in()) {
    $buttons[] = array('#theme' => 'persona_button', '#type' => 'sign_out');
  }
  return array('content' => $buttons);
}

/**
 * Implements hook_block_view_alter().
 */
function persona_block_view_alter(&$data, $block) {
  // Make sure $data is an array.
  // @see https://drupal.org/node/1967802
  if (!is_array($data)) {
    return;
  }
  if (variable_get('persona_takeover') && $block->module == 'user' && $block->delta == 'login') {
    $data['content'] = array();
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function persona_form_user_profile_form_alter(array &$form, array &$form_state, $form_id) {
  if (variable_get('persona_takeover')) {
    $form['account']['mail']['#type'] = 'value';
    $form['account']['mail']['#value'] = $form['account']['mail']['#default_value'];
    $form['account']['pass']['#type'] = 'value';
    $form['account']['current_pass']['#type'] = 'value';
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function persona_form_user_login_alter(array &$form, array &$form_state, $form_id) {
  // Add Persona sign in button to standard sign in page.
  $form['persona'] = array(
    '#theme' => 'persona_button',
    '#weight' => -1,
  );
  // Remove standard sign in form if Persona is taking over completely.
  if (variable_get('persona_takeover')) {
    unset($form['name']);
    unset($form['pass']);
    unset($form['actions']);
  }
}

/**
 * Implements hook_user_view().
 */
function persona_user_view($account) {
  global $user;
  // If a different user is being displayed then do nothing.
  if ($account->uid != $user->uid) {
    return;
  }
  // Add the Change Email button.
  $account->content['persona'] = array('#theme' => 'persona_button', '#type' => 'change_email');
}

/**
 * Implements hook_menu_link_alter().
 */
function persona_menu_link_alter(array &$item) {
  // Add persona-sign-out class to logout menu item.
  if ($item['link_path'] == 'user/logout') {
    $item['options']['attributes']['class'][] = 'persona-sign-out';
  }
}

/**
 * Implements hook_page_alter().
 */
function persona_page_alter(array &$page) {
  // Add a pre-render function to the toolbar.
  if (isset($page['page_top']['toolbar'])) {
    $page['page_top']['toolbar']['#pre_render'][] = 'persona_toolbar_pre_render';
  }
}

/**
 * Adds persona-sign-out class to toolbar logout link.
 */
function persona_toolbar_pre_render(array $toolbar) {
  $toolbar['toolbar_user']['#links']['logout']['attributes']['class'][] = 'persona-sign-out';
  return $toolbar;
}
